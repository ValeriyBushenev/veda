# Платформа VEDA.
## Руководство по разработке приложений.

#### Предисловие
Данное руководство содержит справочную информацию по платформе VEDA и охватывает наиболее важные темы разработки бизнес-приложений на платформе.

Для успешного создания приложений требуется знание следующих технологий:

RDF/RDFS, OWL, Turtle, RDFa, HTML, CSS, JavaScript

Для глубокого понимания принципов работы платформы полезным является знакомство со следующими технологиями и фреймворками:

linux(basic), http, git, ?

Если у Вас имеются предложения по улучшению данного руководства или если вы увидели ошибку в документе, сделайте fork репозитория на GitHub. Мы будем рады принять ваши pull request’ы и issues.

#### Общие сведения
VEDA - это платформа для создания и исполнения бизнес приложений. Исходный код платформы открыт для всех и распространяется бесплатно на условиях лицензии GPLv3.
В основе платформы лежат технологии семантического веба. Это означает что при создании приложения, предметная область (структуры данных и их взаимоотношения) формулируется с помощью словаря описания онтологий OWL/RDF.
Платформа имеет двухзвенную архитектуру и состоит из серверной части и клиентского приложения выполняющегося в браузере пользователя.

#### Возможности и преимущества
Технологии семантического веба дают возможность единообразно описать сущности предметной области. Единое информационное пространство для пользователей работающих в приложениях платформы обеспечивается повторным использованием ранее описанных понятий.
Платформа и используемые технологии помогают разработчику добиваться интеграции данных на семантическом уровне.
Изменения описаний структур данных приложения, при условии сохранении логической совместимости, загружаются в систему на лету и не требуют специальных действий по администрированию сервера.

### 1. Установка и настройка

#### 1.1. Сервер
Сервер платформы состоит из набора онтологий, ряда js скриптов а так-же нескольких бинарных файлов, которые требуется предварительно скомпилировать.
Есть возможность воспользоваться уже собранной платформой, для этого смотрите пункт [1.1.1 Установка заранее собранной системы], в этом варианте количество установленных зависимостей значительно меньше а так-же отсутствует время на компиляцию.

Если требуется вносить изменения в ядро платформы то возможно самостоятельно собрать платформу: [1.2 Самостоятельная сборка из исходных текстов], нужно учесть что в таком варианте понадобится не менее 2 ГБ оперативной памяти.

##### Системные требования
- 64-битная операционная система - linux ubuntu 16.04
- Оперативная память - 1 ГБ минимум, 4 ГБ рекомендуется
- CPU ?
- Место на жестком диске - 5 ГБ.

##### Установка заранее собранной системы
Готовую, собранную заранее платформу можно взять с сайта github.
Для установки последней собранной версии платформы следует выполнить команду git clone https://github.com/semantic-machines/veda-dist.git, далее запустить скрипт ./tools/install-dependencies.sh

##### Самостоятельная сборка из исходных текстов
Исходные файлы проекта, можно взять на сайте github, для этого следует выполнить команду git clone https://github.com/semantic-machines/veda.git

Для работы серверной части системы потребуются компоненты от других разработчиков, все они являются открытыми и могут быть установлены путем запуска скрипта ./control-install.sh

После установки всех зависимостей можно выполнить сборку исполняемых файлов, для этого следует выполнить скрипт ./build.sh

##### Настройка и запуск
Настройки для конфигурирования сервера находятся в файле ./veda.properties.

На первом этапе вам может понадобится внести изменение в настройки tcp портов.
По умолчанию сервер будет производить взаимодействие с клиентской частью по двум портам 8080 и 8088. При необходимости вы можете их перенастроить на необходимые вам.

Порт по которому пользователь будет попадать в систему задается параметром - http_port.
Второй порт отвечает за отправку в клиентское приложение уведомлений об изменениях в данных и задается параметром ccus_port. Более подробно параметры конфигурирования
сервера рассмотрены в разделе [администрирование сервера]
Старт сервера производится командой ./control-start.sh .

При первом запуске, когда база данных пустая, может понадобится некоторое время, примерно около минуты,
в течении которого онтология платформы располагающаяся в папке ./onto, будет переносится в базу данных.
Последующие запуски будут выполнятся без какой либо задержки, то есть практически мгновенно. После того как серверная часть стартовала,
можно перейти в браузер по адресу http://localhost:8080.

При первом запуске системы есть возможность проверить работоспособность компонентов платформы,
для этого в браузере перейдите по адресу адресу http://localhost:8080/tests, в норме все тесты должны пройти успешно.
Остановку сервера можно произвести командой ./control-stop.sh

#### 1.2. База данных
Все файлы базы данных располагаются в папке ./data, которую при необходимости можно слинковать за пределы рабочей папки платформы
Мастер данные хранятся в базе типа ключ значение - tarantool [https://tarantool.io]
Производные данные, такие как индексы полнотекстового поиска и индексы авторизации, хранятся в других базах, к которым прямой доступ из вне ограничен

#### 1.3. Клиентская часть, веб-браузер

##### Системные требования
- операционная система - windows, linux, OSX
- Оперативная память - 1 ГБ минимум, ? ГБ рекомендуется
- CPU ?

Веб-интерфейс приложений, создаваемых на основе платформы, работает в современных браузерах, таких как Google Chrome, Mozilla Firefox, Internet Explorer 11, Microsoft Edge.

#### ? 1.4. Cредства разработки
для редактирования онтологий можно использовать программу protege, https://protege.stanford.edu/

### 2. Быстрый старт

В данном разделе рассматривается создание простого приложения, в качестве средства разработки в данном примере будем использовать обычный текстовый редактор.
При этом содержимое файла должно соответствовать правилам разметки [N3](https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F_3) для RDF данных.

Перед тем как приступать к созданию тестового приложения убедитесь что вы выполнили рекомендованные действия из пункта
[1. Установка и настройка](#1-%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B8-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0)

Основные задачи, стоящие при разработке нашего приложения:

- Разработка модели данных, которая заключается в создании сущностей предметной области.

- Разработка экранных форм пользовательского интерфейса, позволяющих создавать, просматривать, обновлять и удалять сущности модели данных.

### 2.1. Описание задачи

Приложение предназначено для ведения сведений о покупателях и их заказах.

*Покупатель имеет следующие характеристики:*

- Имя
- Электронная почта


*Характеристики заказа:*

- Принадлежность покупателю
- Дата
- Сумма


*Пользовательский интерфейс приложения должен содержать:*

- Форму списка покупателей;
- Форму редактирования сведений о покупателе, содержащее также список заказов данного покупателя;
- Форму общего списка заказов;
- Форму редактирования заказа.

### 2.2. Создание проекта

Для этого создадим текстовый файл sales.ttl, который в дальнейшем будет в себе содержать все сущности данного проекта.

#### заголовок файла проекта
```
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix cs: <http://company-sales.com/sample/sales/> .

<http://company-sales.com/sample/sales>
  rdf:type owl:Ontology ;
  rdfs:isDefinedBy cs: ;
  rdfs:label "Тестовый пример - Продажи"@ru ;
  rdfs:label "Sample - Sales"@en ;
.
```
Рассмотрим из чего состоит заголовок файла:
В самой верхней части файла мы описываем префиксы содержащие в себе ссылки на сторонние онтологии, префикс для нашего проекта зададим следующим образом:
```
@prefix cs: <http://company-sales.com/sample/sales/> .
```
где **cs:** - пространство имен, которое будет использоваться как префикс имен сущностей нашего примера.

**http://company-sales.com/sample/sales/** - ссылка на репозиторий онтологий нашей вымышленной компании.

Далее идет сущность которая будет корневой для других сущностей нашей бизнес области.
```
<http://company-sales.com/sample/sales>
  rdf:type owl:Ontology ;
  rdfs:isDefinedBy cs: ;
  rdfs:label "Тестовый пример - Продажи"@ru ;
  rdfs:label "Sample - Sales"@en ;
.
```

### 2.3. Создание сущностей

Создадим класс сущности Customer (покупатель).

```
cs:Customer
  rdf:type rdfs:Class ;
  rdfs:label "Customer"@en ;
  rdfs:label "Покупатель"@en ;
.

```

Обратите внимание что **cs:Customer** это экземпляр класса **rdfs:Class**, таким образом мы описываем новый класс.

Далее создадим атрибуты сущности.

Начнем с аттрибута **name**, для этого создадим экземпляр класса **owl:DatatypeProperty**

```
cs:name
  rdf:type owl:DatatypeProperty ;
  rdfs:label "Имя"@ru ;
  rdfs:label "Name"@en ;
  rdfs:domain cs:Customer ;
  rdfs:range xsd:string ;
.
```

Здесь предикат **rdfs:domain** указывает принадлежность атрибута **cs:name** к классу **cs:Customer**,
а предикат **rdfs:range** задает тип string для хранимых данных в данном атрибуте.
Так же мы стали использовать новый префикс **xsd:** и поэтому его следует внести в заголовок нашего файла.

Теперь верхняя часть файла с описанием префиксов будет выглядеть так:
```
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix cs: <http://company-sales.com/sample/sales/> .
```

Атрибут **email** создается таким же образом:

```
cs:email
  rdf:type owl:DatatypeProperty ;
  rdfs:label "email" ;
  rdfs:domain cs:Customer ;
  rdfs:range xsd:string ;
.
```

На этом создание сущности **Customer** можно считать завершенным.
Перейдем к созданию сущности Order (заказ).

```
cs:Order
  rdf:type rdfs:Class ;
  rdfs:label "Order"@en ;
  rdfs:label "Заказ"@en ;
.
```

опишем его атрибуты:

```
cs:hasCustomer
  rdf:type owl:ObjectProperty ;
  rdfs:label "has customer"@en ;
  rdfs:domain cs:Order ;
  rdfs:range cs:Customer ;
.
```

Обратите внимание что для описания ссылки на другую сущность мы создали экземпляр класса **owl:ObjectProperty**

Создадим оставшиеся атрибуты **date** и **amount**:

```
cs:date
  rdf:type owl:DatatypeProperty ;
  rdfs:label "date" ;
  rdfs:domain cs:Order ;
  rdfs:range xsd:dateTime ;
.

cs:amount
  rdf:type owl:DatatypeProperty ;
  rdfs:label "amount" ;
  rdfs:domain cs:Order ;
  rdfs:range xsd:decimal ;
.
```

Описание объектной модели завершено, переходим к описанию экранных форм.

### 2.4. Создание форм пользовательского интерфейса

Создадим формы приложения, позволяющие управлять информацией о покупателях и заказах.

#### 2.4.1. Экраны управления Покупателями

#### 2.4.2. Экраны управления Заказами

#### 2.4.3. Меню приложения

#### 2.4.4. Экран редактирования Покупателя со списком Заказов

### 2.5. Загрузка онтологии и тестирование приложения

Посмотрим, как созданное нами описание выглядят в работающем приложении.

Убедитесь что сервер запущен или произведите его запуск командой ./control-start.sh

Один из путей размещения онтологии на сервер, это поместить файл sales.ttl в папку ./onto. Cервер должен обнаружить новый файл, проверить его и если синтаксис не нарушен, внести изменения в базу данных.

Зайдите в систему, использовав имя [admin] и пароль [123] в окне логина. Откройте пункт ?

### 3. Устройство платформы

Данная глава содержит подробное описание архитектуры, компонентов и механизмов платформы.

#### 3.1. Архитектура

В данной главе рассмотрена архитектура VEDA-приложений в различных разрезах: по уровням и модулям.

#### 3.1.1. Уровни приложения

Платформа позволяет строить многоуровневые приложения с выделенными клиентским и серверным уровнями.

##### Сервер

Слой, содержащий описание предметной области, клиентскую и серверную бизнес-логику приложения и выполняющий обращения к базе данных.


##### Клиент

Приложение выполняющееся в веб браузере на JavaScript, и предоставляющее пользовательский интерфейс для внешних пользователей. Поведение и внешний вид клиента зависит от описания предметной области, и клиентской бизнес-логики, которые хранятся на уровне сервера.
Клиент основан на фреймворке ?, работает с серверным слоем через REST API.


---------------------------------------------------------------------

### Основные определения и понятия
- Сущность: Основной элемент модели данных, см. Модель данных.
- Предикат
- Classes : классы
- Individuals – экземпляры
- Data properties – свойства-литералы
- Object properties – свойства-указатели на объекты








