# Платформа VEDA.
## Руководство по разработке приложений.

#### Предисловие
Данное руководство содержит справочную информацию по платформе VEDA и охватывает наиболее важные темы разработки бизнес-приложений на платформе.

Для успешного создания приложений требуется знание следующих технологий:

RDF/RDFS, OWL, Turtle, RDFa, HTML, CSS, JavaScript, git

Для глубокого понимания принципов работы платформы полезным является знакомство со следующими технологиями и фреймворками:

linux(basic), http, websocket

Если у Вас имеются предложения по улучшению данного руководства или если вы увидели ошибку в документе, сделайте fork репозитория на GitHub. Мы будем рады принять ваши pull request’ы и issues.

#### Общие сведения
VEDA - это платформа для создания и исполнения бизнес приложений. Исходный код платформы открыт для всех и распространяется бесплатно на условиях лицензии GPLv3.
В основе платформы лежат технологии семантического веба. Это означает что при создании приложения, предметная область (структуры данных и их взаимоотношения) формулируется с помощью словаря описания онтологий OWL/RDF.
Платформа имеет двухзвенную архитектуру и состоит из серверной части и клиентского приложения выполняющегося в браузере пользователя.

#### Возможности и преимущества
Технологии семантического веба дают возможность единообразно описать сущности предметной области. Единое информационное пространство для пользователей работающих в приложениях платформы обеспечивается повторным использованием ранее описанных понятий.
Платформа и используемые технологии помогают разработчику добиваться интеграции данных на семантическом уровне.
Изменения описаний структур данных приложения, при условии сохранении логической совместимости, загружаются в систему на лету и не требуют специальных действий по администрированию сервера.

### 1. Установка и настройка

#### 1.1. Сервер
Сервер платформы состоит из набора онтологий, ряда js скриптов а так-же нескольких бинарных файлов, которые требуется предварительно скомпилировать.
Есть возможность воспользоваться уже собранной платформой, для этого смотрите пункт *[1.1.1 Установка заранее собранной системы]*, в этом варианте количество установленных зависимостей значительно меньше а так-же отсутствует время на компиляцию.

Если требуется вносить изменения в ядро платформы то возможно самостоятельно собрать платформу: *[1.2 Самостоятельная сборка из исходных текстов]*, нужно учесть что в таком варианте понадобится не менее 2 ГБ оперативной памяти.

##### Системные требования
- 64-битная операционная система - linux ubuntu 16.04
- Оперативная память - 1 ГБ минимум, 4 ГБ рекомендуется
- CPU ?
- Место на жестком диске - 5 ГБ.

##### 1.1.1 Установка заранее собранной системы
Готовую, собранную заранее платформу можно взять с сайта github.
Для установки последней собранной версии платформы следует выполнить команду git clone https://github.com/semantic-machines/veda-dist.git, далее запустить скрипт ./tools/install-dependencies.sh

##### 1.1.2 Самостоятельная сборка из исходных текстов
Исходные файлы проекта, можно взять на сайте github, для этого следует выполнить команду git clone https://github.com/semantic-machines/veda.git

Для работы серверной части системы потребуются компоненты от других разработчиков, все они являются открытыми и могут быть установлены путем запуска скрипта ./control-install.sh

После установки всех зависимостей можно выполнить сборку исполняемых файлов, для этого следует выполнить скрипт ./build.sh

##### 1.1.3 Настройка и запуск
Настройки для конфигурирования сервера находятся в файле ./veda.properties.

На первом этапе вам может понадобится внести изменение в настройки tcp портов.
По умолчанию сервер будет производить взаимодействие с клиентской частью по двум портам 8080 и 8088. При необходимости вы можете их перенастроить на необходимые вам.

Порт по которому пользователь будет попадать в систему задается параметром - http_port.
Второй порт отвечает за отправку в клиентское приложение уведомлений об изменениях в данных и задается параметром ccus_port. Более подробно параметры конфигурирования сервера рассмотрены в разделе [администрирование сервера].
Старт сервера производится командой ./control-start.sh .

При первом запуске, когда база данных пустая, может понадобится некоторое время, примерно около минуты, в течении которого онтология платформы располагающаяся в папке ./onto, будет переносится в базу данных.
Последующие запуски будут выполнятся без какой либо задержки, то есть практически мгновенно. После того как серверная часть стартовала, можно перейти в браузер по адресу http://localhost:8080.

При первом запуске системы есть возможность проверить работоспособность компонентов платформы, для этого в браузере перейдите по адресу адресу http://localhost:8080/tests, в норме все тесты должны пройти успешно.
Остановку сервера можно произвести командой ./control-stop.sh

#### 1.2. База данных
Все файлы базы данных располагаются в папке ./data, которую при необходимости можно прилинковать за пределы рабочей папки платформы.
Мастер данные хранятся в базе типа ключ значение - tarantool [https://tarantool.io]
Производные данные, такие как индексы полнотекстового поиска и индексы авторизации, хранятся в других базах, к которым прямой доступ из вне ограничен.

#### 1.3. Модули
Платформа содержит в своем составе менеджер модулей, который позволяет устанавливать/удалять сторонние модули учитывая версионность самих модулей и их зависимостей.

#### 1.4. Клиентская часть, веб-браузер

##### Системные требования
- операционная система - windows, linux, OSX
- Оперативная память - 1 ГБ минимум, ? ГБ рекомендуется
- CPU ?

Веб-интерфейс приложений, создаваемых на основе платформы, работает в современных браузерах, таких как Google Chrome, Mozilla Firefox, Internet Explorer 11, Microsoft Edge.

#### 1.5. Cредства разработки

В процессе создания приложения, специальных средств разработки как правило не требуется, достаточно простых текстовых редакторов, однако некоторые инструменты могут облегчить разработку.

Для редактирования онтологий можно использовать программу *Protege*: https://protege.stanford.edu/
это бесплатный open-source редактор, либо более продвинутый инструмент *TopBraid Composer Standard Edition*.

### 2. Быстрый старт

В данном разделе рассматривается создание простого приложения, в качестве средства разработки в данном примере будем использовать обычный текстовый редактор.
При этом содержимое файла должно соответствовать правилам разметки [N3](https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F_3) для RDF данных.

Перед тем как приступать к созданию тестового приложения убедитесь что вы выполнили рекомендованные действия из пункта
[1. Установка и настройка](#1-%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B8-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0)

Основные задачи, стоящие при разработке нашего приложения:

- Разработка модели данных, которая заключается в создании сущностей предметной области.

- Разработка экранных форм пользовательского интерфейса, позволяющих создавать, просматривать, обновлять и удалять сущности модели данных.

### 2.1. Описание задачи

Приложение предназначено для ведения сведений о покупателях и их заказах.

*Покупатель имеет следующие характеристики:*

- Имя
- Электронная почта


*Характеристики заказа:*

- Принадлежность покупателю
- Дата
- Сумма


*Пользовательский интерфейс приложения должен содержать:*

- Форму списка покупателей;
- Форму редактирования сведений о покупателе, содержащее также список заказов данного покупателя;
- Форму общего списка заказов;
- Форму редактирования заказа.

### 2.2. Создание проекта

В данном примере, для простоты мы не будем использовать возможности менеджера модулей, более подробно с этой технологией можно ознакомится в разделе [Менеджер модулей].

Для нашего примера создадим текстовый файл sales.ttl, который в дальнейшем будет в себе содержать все сущности данного проекта.

#### заголовок файла проекта
```
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix cs: <http://company-sales.com/sample/sales/> .

<http://company-sales.com/sample/sales>
  rdf:type owl:Ontology ;
  rdfs:isDefinedBy cs: ;
  rdfs:label "Тестовый пример - Продажи"@ru ;
  rdfs:label "Sample - Sales"@en ;
.
```
Рассмотрим из чего состоит заголовок файла:
В самой верхней части файла мы описываем префиксы содержащие в себе ссылки на сторонние онтологии, префикс для нашего проекта зададим следующим образом:

```
@prefix cs: <http://company-sales.com/sample/sales/> .
```
где **cs:** - пространство имен, которое будет использоваться как префикс имен сущностей нашего примера.

**http://company-sales.com/sample/sales/** - ссылка на репозиторий онтологий нашей вымышленной компании.

Далее идет сущность которая будет корневой для других сущностей нашей бизнес области.
```
<http://company-sales.com/sample/sales>
  rdf:type owl:Ontology ;
  rdfs:isDefinedBy cs: ;
  rdfs:label "Тестовый пример - Продажи"@ru ;
  rdfs:label "Sample - Sales"@en ;
.
```

### 2.3. Создание сущностей

Создадим класс сущности Customer (покупатель).

```
cs:Customer
  rdf:type rdfs:Class ;
  rdfs:label "Customer"@en ;
  rdfs:label "Покупатель"@ru ;
.

```

Обратите внимание что **cs:Customer** это экземпляр класса **rdfs:Class**, таким образом мы описываем новый класс.

Далее создадим атрибуты сущности.

Начнем с аттрибута **name**, для этого создадим экземпляр класса **owl:DatatypeProperty**

```
cs:name
  rdf:type owl:DatatypeProperty ;
  rdfs:label "Имя"@ru ;
  rdfs:label "Name"@en ;
  rdfs:domain cs:Customer ;
  rdfs:range xsd:string ;
.
```

Здесь предикат **rdfs:domain** указывает принадлежность атрибута **cs:name** к классу **cs:Customer**,
а предикат **rdfs:range** задает тип string для хранимых данных в данном атрибуте.
Так же мы стали использовать новый префикс **xsd:** и поэтому его следует внести в заголовок нашего файла.

Теперь верхняя часть файла с описанием префиксов будет выглядеть так:
```
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix cs: <http://company-sales.com/sample/sales/> .
```

Атрибут **email** создается таким же образом:

```
cs:email
  rdf:type owl:DatatypeProperty ;
  rdfs:label "email" ;
  rdfs:domain cs:Customer ;
  rdfs:range xsd:string ;
.
```

На этом создание сущности **Customer** можно считать завершенным.
Перейдем к созданию сущности Order (заказ).

```
cs:Order
  rdf:type rdfs:Class ;
  rdfs:label "Order"@en ;
  rdfs:label "Заказ"@ru ;
.
```

опишем его атрибуты:

```
cs:hasCustomer
  rdf:type owl:ObjectProperty ;
  rdfs:label "has customer"@en ;
  rdfs:domain cs:Order ;
  rdfs:range cs:Customer ;
.
```

Обратите внимание что для описания ссылки на другую сущность мы создали экземпляр класса **owl:ObjectProperty**

Создадим оставшиеся атрибуты **date** и **amount**:

```
cs:date
  rdf:type owl:DatatypeProperty ;
  rdfs:label "date" ;
  rdfs:domain cs:Order ;
  rdfs:range xsd:dateTime ;
.

cs:amount
  rdf:type owl:DatatypeProperty ;
  rdfs:label "amount" ;
  rdfs:domain cs:Order ;
  rdfs:range xsd:decimal ;
.
```

Описание объектной модели завершено, переходим к описанию экранных форм.

### 2.4. Создание форм пользовательского интерфейса

Создадим формы приложения, позволяющие управлять информацией о покупателях и заказах.

#### 2.4.1. Экраны управления Покупателями

-

#### 2.4.2. Экраны управления Заказами

-

#### 2.4.3. Меню приложения

-

#### 2.4.4. Экран редактирования Покупателя со списком Заказов

-

### 2.5. Запуск приложения

Посмотрим, как созданное нами описание выглядит в виде готового приложения.

##### 2.5.1 Загрузка онтологии

Убедитесь что сервер запущен или произведите его запуск командой ./control-start.sh

Один из путей размещения онтологии на сервер, это поместить файл sales.ttl в папку ./onto. Cервер должен обнаружить новый файл, проверить его и если синтаксис не нарушен, внести изменения в базу данных.

##### 2.5.2 Тестирование приложения

Зайдите в систему, использовав имя [admin] и пароль [123] в окне логина. Откройте пункт меню ?



### 3. Устройство платформы

Данная глава содержит подробное описание архитектуры, компонентов и механизмов платформы.

### 3.1. Архитектура приложения

В данной главе рассмотрена архитектура VEDA-приложений в различных разрезах: по уровням и модулям.

#### 3.1.1. Уровни приложения

Платформа позволяет строить многоуровневые приложения с выделенными клиентским и серверным уровнями.

##### Сервер

Слой, содержащий описание предметной области, клиентскую и серверную бизнес-логику приложения и выполняющий обращения к базе данных.


##### Клиент

Приложение выполняющееся в веб браузере на JavaScript, и предоставляющее пользовательский интерфейс для внешних пользователей. Поведение и внешний вид клиента зависит от описания предметной области, и клиентской бизнес-логики, которые хранятся на уровне сервера.
Клиентская часть работает с серверным слоем через HTTP API и websocket.

#### 3.1.2. Модули приложения

Модуль - это набор из связанных между собой ресурсов. В набор входят следующие виды файлов: 

- Онтологии размещенные в ttl файлах.
- Компоненты необходимые для построения пользовательского UI (css, fonts, images ...).
- JavaScript библиотеки и скрипты необходимые для работы модуля.
- Описание модуля и его зависимостей.
- Тесты.

Приложение для своего функционирования может требовать наличие других модулей, это задается в в разделе зависимости, в сущности описывающей модуль.

Само приложения так же является модулем и может в дальнейшем использоваться для построения других приложений.



### 3.2. Архитектура платформы

В данной главе рассмотрена архитектура платформы в разрезе компонентов и функциональных блоков, также структура и направление потоков информации.

#### 3.2.1 Серверные компоненты и их функциональные блоки

- **veda-mstorage**

  - Аутентификация.
  - Авторизация изменений.
  - Запись в основное хранилище сущностей.
  - Индексация сущностей для последующей авторизации.
- **veda-ft-indexer**

  - индексация сущностей для полнотекстового поиска.
- **veda-ft-query** (возможен одновременный запуск необходимого количества)
  - Выполнение запросов к полнотекстовому поиску.
  - Авторизация полученных результатов.
- **veda-fanout-email**

  - Отправка по e-mail.
- **veda-fanout-sql-np**

  - Выгрузка в SQL.
- **veda-scripts**

  - Исполнение скриптов.
- **veda-ttlreader**

  - Чтение ttl файлов, извлечение из них сущностей.
  - Подключение к очереди другого экземпляра системы Veda.
- **veda-ccus**

  - Обслуживание websocket API (уведомление об изменениях).
- **veda-gowebserver** (возможен одновременный запуск множества веб-серверов)

  - Обслуживание HTTP API.

  - Авторизация запрашиваемых сущностей.

    

![компоненты veda](veda-schema.svg)

##### рисунок 1. Функциональные части платформы veda и движение потоков информации.



#### 3.2.2 Жизненный цикл обработки информации: 

*Пути поступления информации в систему:*

1. Чтение ttl файлов доступ к которым имеет серверная часть.
2. HTTP API
   - Пользователь посредством веб интерфейса производит создание или модификацию сущностей.
   - Другие системы могут получать и отправлять сущности.
3. Чтение очереди другого экземпляра системы Veda.

*Обработка поступившей информации на стороне сервера:*

На серверной стороне, компонент хранения обрабатывает поступившие сущности и после проверки прав доступа, сохраняет в мастер базу, а так-же складывает в очередь. При этом в очередь сохраняются два состояния: сущность до изменений и ее новое состояние. 
Далее компонент хранения уведомляет остальные части системы  о поступлении новых данных. На следующей стадии каждый из компонентов считывает из очереди новую порцию данных, и исходя из содержимого делает вывод о том следует обрабатывать или пропустить. 
Каждый из компонентов системы может содержать свои базы данных и алгоритмы работы. В процессе обработки поступившей сущности, могут быть сгенерированны новые сущности которые будут отправлены в компонент хранения и далее цикл обработки повторится.



### 3.3. API для клиентского слоя

**HTTP API предоставляет следующую функциональность:**

- Аутентификация пользователя и получение сессионного билета.
- Проверка сессионного билета на валидность.
- Сохранение одной или нескольких сущностей.
- Получение одной или нескольких по их ID.
- Удаление сущности.
- Добавление, обновление, удаление заданного поля в сущности.
- Получение разрешений для текущего пользователя и сущности.
- Загрузка и скачивание файлов.
- Получение информации о текущей позиции в очереди для каждого серверного компонента
- Поддерживает анонимный доступ c ограниченными правами.

**Websocket API служит для оперативного получения изменений в сущностях и состоит из следующих команд:**

- Получить текущий набор подписок .
- Подписка на изменения одной или нескольких сущностей.
- Отменить подписку для  одной или нескольких сущностей.
- Отменить все подписки.

  

### 3.4. Механизмы платформы

#### 3.4.1 Язык запросов VQL

в общем виде запросы строятся так:

('ПРЕДИКАТ1' == 'ЧТО ИЩЕМ1' && 'ПРЕДИКАТ2' == 'ЧТО ИЩЕМ2') || ('ПРЕДИКАТ3' == 'ЧТО ИЩЕМ3')

== означает поиск с учетом иерархии классов

=== более строгий чем == поиск, то есть ищет только тот класс который указан

с правой стороны выражения в '' кавычках может быть выражение с таким синтаксисом https://xapian.org/docs/queryparser.html

с левой стороны выражения вместо 'ПРЕДИКАТ' может быть '*' это значит надо искать в любом поле

с правой стороны может быть такое выражение 'ИЩЕМ*', это значит не определено окончание и будут использованы все словоформы но не более 20 000 вариантов этого слова

еще есть вложенные поля:  'ПРЕДИКАТ1.ПРЕДИКАТ2'

есть предопределенное поле ПРЕДИКАТ1.isExists, по нему можно узнать есть ли хоть что то в поле

поиск по диапазонам [ЗНАЧЕНИЕ1, ЗНАЧЕНИЕ2], пример:
( ( 'rdf:type'==='mnd-s:Idea' ) && ( 'v-s:created'==[2017-05-31T21:00:00.000Z,2017-06-30T20:59:59.999Z] ) )

косвенно можно указать в какой базе искать: сейчас поток индексация делится на три части: basic, system и deleted
например чтоб поискать в удаленных, нужно явно указать что поле 'v-s:deleted' === true

есть возможность указать номер слота в запросе вместо предиката, пример: '#123' == 'текст'

по умолчанию весь поиск происходит по базе basic
схема индексации находится здесь: veda-index.ttl

есть сортировки по набору полей, и указания сколько нужно будет выбрать индивидов (TOP), сколько всего просматривать в запросе (LIMIT), и сколько отступить при выборке TOP, (FROM)

протестировать запросы можно в запущенном приложении: http://localhost/#/search

ПРИМЕРЫ:

'*' == 'лесовик' - поиск документов содержащих слова [лесовик] по любому полю любых документов
'*' == 'лес*'- поиск документов содержащих слова начинающихся на [лес] по любому полю любых документов
'*' == 'лес*' && '*' == 'вод*' - поиск документов содержащих слова начинающихся на [лес] И начинающихся на [вод] по любым полям любых документов
'*' == 'лес*' || '*' == 'вод*' - поиск документов содержащих слова начинающихся на [лес] ИЛИ начинающихся на [вод] по любым полям любых документов
'*' == 'лес*' && ('*' == 'вод*' || '*' == 'мотор*')
'rdfs:label' == 'лес*' - поиск документов содержащих слова начинающихся на [лес] по полю rdfs:label
'v-s:owner.isExists' == 'true' - поиск документов содержащих поле v-s:owner с любым содержимым
'rdf:type'=='v-s:Organization' - находим документы с типом v-s:Organization и c типом Филиал
'rdf:type'==='v-s:Organization'- находим только документы с типом v-s:Organization
'rdf:type'==='mnd-s:Idea'  &&  'v-s:created'==[2017-05-31T21:00:00.000Z,2017-06-30T20:59:59.999Z] - документы типа mnd-s:Idea с датой создания в диапазоне от 2017-05-31T21:00:00.000Z до 2017-06-30T20:59:59.999Z
'rdf:type'==='mnd-s:Idea'  && 'v-s:deleted' === true - документы типа mnd-s:Idea которые были удалены
'rdf:type'==='v-wf:Process' - документы типа v-wf:Process, однако найти такие можно только указав явно тип v-wf:Process
'*' == '+лес +вод' - документы содержащие слова [лес] + [вод] вместе в любых полях
'*' == '(№177 177а, 2017-06-28)' - документы содержащие фрагменты токенов №177 177а, 2017-06-28 в любых полях
'*' == '"(№177 177а, 2017-06-28)"' - документы содержащий точную фразу [(№177 177а, 2017-06-28)] в любых полях
'@' === 'v-s:Organization' находим документы с id = v-s:Organization

#### 3.4.2. Подсистема безопасности

I. Назначение полей, генерация дополнительных данных, обзор алгоритма авторизации

  1. Включение реальных людей в группы должностей (на сервере).
     1.1. При сохранении индивида класса Appointment запускается обработчик.
     1.2. Создается индивид класса принадлежность (Membership).
     1.3. Значением предиката v-s:resource устанавливается значение предиката v-s:employee из назначения.
     1.4. Значением предиката v-s:memberOf устанавливается значение предиката v-s:occupation из назначения.
     1.5. Выполняется команда put_individual для принадлежности.
     1.6. Выполнение обработчика завершается.

  2. Назначение прав автору нового индивида.

     На стороне клиента:
     2.1. При создании нового индивида, клиентское приложение дополняет индивид предикатами v-s:author, v-s:created.
     2.2. Значением предиката v-s:author устанавливается текущее (выбранное) назначение пользователя.
     2.3. Значением предиката v-s:created устанавливается текущий момент времени.
     2.4. В момент выполнения команды сохранения индивида, клиент выполняет команду put_individual.

     На стороне сервера (server js script):
     2.5. При выполнении команды (put_individual) запускается обработчик.
     2.6. Считывается предыдущее состояние записываемого индивида.
     2.7. Если предыдущего состояния не существует, то индивид считается новым, и для него необходимо установить права доступа.
          В противном случае сравниваются значения предикатов v-s:author старого и нового состояния индивида.
            Если значения совпадают, обработчик прекращает свою работу (права уже выданы ранее).
            Если значения различаются, индивид приводится к старому состоянию, выполняется команда put_individual
            (не даем подменить автора существующего объекта).
     2.8. Информация об авторе индивида извлекается из предиката v-s:author.
     2.9. Выполняется проверка соответствия пользователя от имени которого идет операция записи и назначения, указанном в предикате v-s:author.
          (Это необходимо для того, чтобы нельзя было подделать авторство индивида.)
          При выполнении проверки, uri пользователя (Person), вычисляемый из тикета, сравнивается со значением предиката v-s:employee, указанном в назначении.
            Если значения различаются, в индивид вписывается предикат v-s:deleted со значением true,
            выполнение обработчика завершается (права не назначаются, индивид никому не будет доступен).
            Если значения совпадают, создается запись авторизации (PermissionStatement).
              Значение предиката v-s:subject устанавливается равным значению v-s:occupation из назначения (должность).
              Значение предиката v-s:object устанавливается равным uri создаваемого субъекта.
              Значение предиката v-s:canCreate, v-s:canRead, v-s:canUpdate, v-s:canDelete устанавливается равным true.
              Выполняется команда put_individual для записи авторизации.
              Выполнение обработчика завершается.

  3. Авторизация доступа к индивиду.
     При выполнении проверки прав доступа (на сервере).
     3.1. По тикету вычисляется пользователь.
     3.2. Производится извлечение всех групп, в которых состоит пользователь, с учетом вложенности групп друг в друга.
     3.3. Производится извлечение всех групп, в которых состоит запрашиваемый ресурс, с учетом вложенности групп друг в друга.
     3.4. Производится извлечение подходящих записей авторизации, в которых есть группа пользователя и группа ресурса с
            необходимым уровнем прав и вычисление прав с учетом ограничений установленных в группах.

II. Структуры хранения данных авторизации

  Для хранения авторизационных данных применяются индивиды трех видов:

    1. v-s:Group : группа для идентификации подмножества ресурсов.

    2. v-s:Membership : запись о вхождении индивида [v-s:resource] в группу [v-s:memberOf].
     Допускается вложение групп в группы, при этом поля [v-s:canCreate, v-s:canDelete, v-s:canRead, v-s:canUpdate], ограничивают права для вложенных групп.

    3. v-s:PermissionStatement : запись связывающая субъекта авторизации [v-s:permissionSubject],
     объекта авторизации [v-s:permissionObject] правами [v-s:canCreate, v-s:canDelete, v-s:canRead, v-s:canUpdate],
     при этом субъектом и объектом авторизации могут выступать как индивиды типа v-s:Person, так и группы

  Для быстрого извлечения авторизационных данных, на сервере, в отдельной базе формируются индексы:

  1. Индекс формируемый из субъекта типа v-s:Membership
     * Ключ индекса совпадает с ключом ресурса + "_m".
     * В записи присутствуют только те группы, в которые ресурс входит непосредственно (есть субъект Membership).

     Пример записи membership:

     ```
     object_uri_m : {
       object_group_uri1 : 2, // R
       object_group_uri2 : 2, // R
       object_group_uri3 : 15 // CRUD
     }
     ```

     

     * Уровень прав вхождения в группу по-умолчанию считается равным CRUD.

  2. Индекс формируемый из субъектов типа v-s:PermissionStatement
     * Ключ индекса permission совпадает с ключом ресурса + "_p".
     * В записи присутствуют только те разрешения, которые были выданы непосредственно на этот ресурс (есть субъект PermissionStatement).

     Пример записи permission:

     ```
     object_uri_p : {
       subject_group_uri1 : 2,  // R
       subject_group_uri2 : 2,  // R
       subject_group_uri3 : 15  // CRUD
     }
     ```

     

III. Алгоритм вычисления права доступа, используя предпостроенные индексы:

  object - объект доступа
  subject - субъект доступа

    1. Получаем цепочки всех групп объекта, запрашивая записи membership по сформированному uri:  object_uri + "_m".
       При этом, если в цепочке принадлежностей был указан уровень прав, этим же уровнем помечаются все группы далее по цепочке.
         Поскольку уровень прав одних и тех же групп в разных цепочках иерархии может отличаться,
         формируем общий хэш групп объекта с указанием для каждой группы всех уровней прав из разных цепочек (object_groups).
         В общий хэш групп объекта включаем сам объект.

  Пример:

```
 object_groups = {
    // включаем сам объект
    object_uri: [ 15 ],           // [ CRUD ]
    object_group_uri1: [ 2, 15 ], // [ R, CRUD ]
    object_group_uri2: [ 2 ],     // [ R ]
    object_group_uri3: [ 2 ],     // [ R ]
  }

2. 
```

Получаем цепочки всех групп субъекта (пользователя).
Формируем общий хэш групп, в которые входит субъект (персона). Операция аналогична п.1.
  В общий список групп субъекта включаем сам субъект.

  Пример:

```
subject_groups = {
    // включаем сам субъект
    subject_uri : [ 15 ],
    subject_group_uri1 : [ 15 ],
    subject_group_uri2 : [ 15 ],
    subject_group_uri3 : [ 15 ]
  }
```



    3. Для каждого ключа obj_key хэша objects_groups извлекаем запись permission по сформированному uri:  obj_key + "_p".

  Пример:

```
object_uri_p : {
    subject_group_uri3 : 15 // CRUD
  }
```

4. Для каждого ключа perm_key в хэше permission проверяем, есть ли такой ключ в хэше subject_groups.
   При наличии ключа выполняем операцию побитового "И" каждого значения из списка object_groups[obj_key] со значением permission[perm_key],
     а потом с запрашиваемым уровнем прав.
     Если итог выполнения операции не 0, прекращаем обработку - запрашиваемое право подтверждено.

  * Для оптимизации количества обращений к базе данных используем вытесняющий кэш (с учетом частоты запроса конкретного элемента!) для записей membership и permission.
  * После некоторого времени, за счет использования вытесняющего кэша, количество обращений к базе данных резко сократится,
    поскольку в него войдут группы объектов высокого уровня и их разрешения (например, классы и группы орг. структуры).
  * Дополнительно можно хранить в памяти предпостроенные цепочки групп ресурсов из кэша (для ускорения вычисления object_groups, subject_groups).

VI. Пример реализации алгоритма вычисления права доступа, используя пред построенные индексы на javascript:

~~~javascript
// AUTHORIZATION

var C = 1,
    R = 2,
    U = 4,
    D = 8;

var admin_ticket = _get_admin_ticket();

// MAIN FUNCTION
function authorize(subject_uri, object_uri, right) {

  var object_groups = get_resource_groups(object_uri),
      subject_groups = get_resource_groups(subject_uri);

  for (var obj_key in object_groups) {

```
var permissions = get_permissions(obj_key);

for (var perm_key in permissions) {
  if (perm_key in subject_groups) {
    var list = object_groups[obj_key],
      length = list.length;
    for (var i = 0; i < length; i++ ) {
      if ( (list[i] & permissions[perm_key]) & right ) {
        return true;
      }
    }
  }
}
```

  }
  return false;
}

// UTILS
function get_permissions(resource_uri) {
  return _get_individual(admin_ticket, resource_uri + "_p");
}

function get_resource_groups(resource_uri) {
  var result = {};
  result[resource_uri] = [C|R|U|D];
  return _get_resource_groups(resource_uri, result, C|R|U|D);
}

function _get_resource_groups(resource_uri, acc, rights) {
  if (resource_uri === "v-s:AllResourcesGroup") return;

  var membership_uri = resource_uri + "_m",
    membership = _get_individual(admin_ticket, membership_uri);

  if (!membership) return;

  for (var key in membership) {
    acc[key] = acc[key] || [];
    rights = membership[key] & rights;
    acc[key].push( rights );
    _get_resource_groups(key, acc, rights);
  }

  return acc;
}
~~~

~~~javascript
// TEST DATA

function _get_admin_ticket() {
  return 1;
}

function _get_individual(ticket, uri) {
  get_count++;
  get_stats[uri] = get_stats[uri] ? ++get_stats[uri] : 1;
  var result;

  switch (uri) {

```
// objects memberships
case "add1_m" :
  result = {
    "v-s:AllResourcesGroup" : C|R|U|D,
    "im1": C|R|U|D
  }; break;
case "ver1_m" :
  result = {
    "v-s:AllResourcesGroup" : C|R|U|D,
    "im1": R
  }; break;
case "im1_m" :
  result = {
    "v-s:AllResourcesGroup" : C|R|U|D,
    "imc": C|R|U|D
  }; break;
case "imc_m" :
  result = {
    "v-s:AllResourcesGroup" : C|R|U|D,
    "doc": C|R|U|D
  }; break;
case "doc_m" :
  result = {
    "v-s:AllResourcesGroup" : C|R|U|D
  }; break;

// subjects memberships
case "p1_m" :
  result = {
    "v-s:AllResourcesGroup" : C|R|U|D,
    "pg1" : C|R|U|D,
    "pg2" : C|R|U|D
  }; break;
case "pg1_m" :
  result = {
    "v-s:AllResourcesGroup" : C|R|U|D,
    "mnd" : C|R|U|D
  }; break;
case "pg2_m" :
  result = {
    "v-s:AllResourcesGroup" : C|R|U|D,
    "mnd" : C|R|U|D
  }; break;
case "mnd_m" :
  result = {
    "v-s:AllResourcesGroup" : C|R|U|D
  }; break;

// object permissions
case "im1_p" :
  result = {
    "p1" : C|R|U
  }; break;
/*case "imc_p" :
  result = {
    "mnd" : R
  }; break;
case "doc_p" :
  result = {
    "mnd" : C|R|U
  }; break;
case "ver1_p" :
  result = {
    "p1" : C|R|U|D
  }; break;
*/
```
  }
  return result;
}
~~~



```javascript
// TEST

var get_count = 0;
var get_stats = {};

// p1 -> im1
get_count = 0;
console.log("authorize('p1', 'im1', C)", authorize('p1', 'im1', C), "get_count", get_count);
get_count = 0;
console.log("authorize('p1', 'im1', R)", authorize('p1', 'im1', R), "get_count", get_count);
get_count = 0;
console.log("authorize('p1', 'im1', U)", authorize('p1', 'im1', U), "get_count", get_count);
get_count = 0;
console.log("authorize('p1', 'im1', D)", authorize('p1', 'im1', D), "get_count", get_count);

// p1 -> add1
get_count = 0;
console.log("authorize('p1', 'add1', C)", authorize('p1', 'add1', C), "get_count", get_count);
get_count = 0;
console.log("authorize('p1', 'add1', R)", authorize('p1', 'add1', R), "get_count", get_count);
get_count = 0;
console.log("authorize('p1', 'add1', U)", authorize('p1', 'add1', U), "get_count", get_count);
get_count = 0;
console.log("authorize('p1', 'add1', D)", authorize('p1', 'add1', D), "get_count", get_count);

// p1 -> ver1
get_count = 0;
console.log("authorize('p1', 'ver1', C)", authorize('p1', 'ver1', C), "get_count", get_count);
get_count = 0;
console.log("authorize('p1', 'ver1', R)", authorize('p1', 'ver1', R), "get_count", get_count);
get_count = 0;
console.log("authorize('p1', 'ver1', U)", authorize('p1', 'ver1', U), "get_count", get_count);
get_count = 0;
console.log("authorize('p1', 'ver1', D)", authorize('p1', 'ver1', D), "get_count", get_count);

console.log("get_stats", get_stats);
```

**Эксклюзивные права.**

Данный вид прав позволяет ограничить доступ для отдельных групп пользователей, такое может понадобится например если в системе есть пользователи из разных организаций

для этого следует создать включение в групп с специальным признаком v-s:isExclusive = true:

mnd-s:InternalDocumentToCompany1_membership
  rdf:type v-s:Membership ;
  v-s:memberOf mnd-s:InternalDocument_group ;
  v-s:resource d:org_Company1 ;
  rdfs:label "Внутренние документы доступные для Компании 1" ;
  v-s:isExclusive "true"^^xsd:boolean ;
.

после внесения такой записи, для пользователей входящих по иерархии в группу d:org_Company1, на обычную для них авторизацию будет налагатся ограничение:
теперь авторизуемый обьект должен входить по иерархии CLASS_GROUP_HIERARCHY в группу mnd-s:InternalDocument_group, иначе он не будет доступен.

структура CLASS_GROUP_HIERARCHY:
    - группы содержащие v-s:isExclusive = true в иерархию не входят
    - в 0 уровень могут входить любые группы
    - для уровня > 0 предыдущий уровень должен содержать строку '_group' или сfg:TTLResourcesGroup
    - индивиды не имеющие на первом уровне иерархии групп с '_group' или сfg:TTLResourcesGroup, считаются системными и на них не действуют ограничения.

ВНИМАНИЕ! при наличии хотя бы одной записи о включения в группу с признаком v-s:isExclusive, для ограничивающей группы пользователей произойдет потеря всех прав кроме прав на онтологию и
прав разрешаемых с помощью этой записи.



#### 3.4.2. Подсистема исполнения скриптов

Серверная часть платформы, имеет возможность исполнения по событию, заранее внесенного в систему скрипта. Скрипты исполняются в момент когда произошло обновление сущности.

Есть два пути внесения в систему необходимых скриптов: 

1. Создать сущность с типом v-s:Event:
   В поле v-s:script,  записывается непосредственно код скрипта, поле v-s:triggerByType дает возможность отфильтровать события по измерению сущностей только определенного типа.

пример:

```
cfg:Event_Notify_Task
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "Скрипт уведомления о новой задаче" ;
  v-s:triggerByType v-wf:UserTaskForm ;
  v-s:script """
    var task_id = document["@"],
    to = getUri(document["v-wf:to"]);
    print("cfg:Event_17", "caught", "task", task_id, "to", to);
  """ ;
.
```



2. Второй способ внесения в систему скриптов это размещения кода в файловой системе в папке ./public/js. 
   Однако такие скрипты невозможно привязать к событиям обновления сущности, но их можно вызвать из v-s:Event. 
   Разработчик имеет возможность сформировать базовый набор утилит для последующего использования в сущностях типа v-s:Event.

Особенности исполнения скриптов:

По сути скрипт в v-s:Event это аналог триггера в SQL, вернуть он ничего не может, но в нем можно создать или изменить любую сущность.

При исполнении скрипта, ему передаются ряд предустановленных переменных:

- ticket = superuser ticket
- document = captured document
- user_uri = user whose actions triggered event
- prev_state = user whose actions triggered event
- _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
- parent_script_id = id of the parent script that triggered this event.
- parent_document_id = id of the document that triggered this event.

!  prev_state состояние объекта до момента изменения объекта, если требуется актуальное состояние то следует считать обьект самостоятельно.
!  всем скриптам исполняемым в рамках события изменения сущности, подается одно и тоже состояние prev_state.

При сохранении сущности будут выполнены все скрипты которые проходят по фильтру v-s:triggerByType для типа этой сущности.
Порядок исполнения скриптов не регулируется. Исполнение скрипта может повлечь за собой новое исполнение скриптов, так как в теле кода могут располагаться команды на создание или обновление сущностей. Однако сохранение новых и измененных сущностей будет произведено только после того как отработают все скрипты по первоначальному событию. 
Соответственно вложенные скрипты будут вызваны только после того как сохраняться результаты работы родительского скрипта.
В самом исполняемом скрипте можно узнать откуда его вызвали если обратится к переменной parent_script_id. Соответственно, в переменной parent_document_id будет содержатся id сущности в результате обработки которого был вызван вложенный скрипт.

Поток исполнения:

Модифицированные сущности и вновь созданные, veda складывает в одну очередь, которая затем обрабатывается различными частями системы.
Для скриптов этот поток данных делится на три части, которые обрабатываются тремя экземплярами js машин, отвечающими за исполнение js скриптов.

Каждая из js машин обрабатывает свою очередь и имеет независимый контекст, нужно учитывать что глобальные переменные созданные в одной из машин, будут не доступны в других.

Также нужно учесть что js машины исполнения не равноценны по приоритетам, используются три фиксированные очереди исполнения скриптов: lp0 и lp1 - низко приоритетные и main - высоко приоритетная.

Исполнение в очередях lp0 и lp1 не может обгонять исполнение очереди main, то есть обработка ceoyjcnb в низко приоритетных очередях будет выполнена после того как будет завершена обработка этой сущности в высоко приоритетной очереди.

Для указания в какой из очередей скрипт должен исполняться, задается предикатом [v-s:runAt] :
v-s:runAt "V8.LowPriority" для очереди lp0, v-s:runAt "V8.LowPriority1" для очереди lp1. Отсутствие предиката v-s:runAt для скрипта говорит о том что данный скрипт должен исполнятся в очереди main.

Для предотвращения ситуаций перепутывания порядка исполнения скриптов, используется правило: сущности порожденные в очереди X, в дальнейшем будут обработаны в ней же.

Также можно указать для конкретной сущности, где она должна быть обработана, но это действует только для сущностей созданных пользователем, а не скриптом.

псевдокод этого алгоритма:

```
vm_id = id машины исполнения скриптов (V8.LowPriority/V8.LowPriority1/main)
indv_run_at = обрабатываемый_индивид.getFirstLiteral("v-s:runAt");

цикл по скриптам
{
		script_run_at = скрипт.getFirstLiteral("v-s:runAt");

​```
            if (обрабатываемый_индивид создан пользователем (а не скриптом) == true)
            {
                if (indv_run_at !is null && indv_run_at != vm_id)
                    continue;
                else if (indv_run_at is null && script_run_at != vm_id)
                    continue;
            }

исполнение скрипта
​```

}


```

сохранение результатов



### 3.5. Компоненты платформы исходящей информации

#### 3.5.1 Отправка по e-mail

Почтовые уведомления.

1) у v-s:Person может быть заполнена ссылка v-ui:hasPreferences на объект типа v-ui:Preferences.
2) В этом объекте (предпочтения) может быть заполнено поле v-ui:receiveMessageType (получать сообщения определенного типа). Значениями этого свойства являются индивиды класса v-s:MessageType.
3) Объекты типа v-s:Email могут иметь свойство v-s:hasMessageType. Значениями этого свойства являются индивиды класса v-s:MessageType.
4) Перед отправкой письма нужно проверить значение свойства v-s:hasMessageType (0 или 1 значение) у Письма и значения свойства v-ui:receiveMessageType у Предпочтений (может быть несколько значений).

Письмо ОТПРАВЛЯЕМ:
  * Если v-ui:receiveMessageType в предпочтениях содержит значение свойства v-s:hasMessageType из Письма
  * Если свойство v-s:hasMessageType отсутствует в письме, а свойство v-ui:receiveMessageType в предпочтениях содержит значение v-s:OtherNotification

#### 3.5.2 Выгрузка в SQL

### 3.6. Модули поставляемые с платформой





### 4. Разработка приложений

### 4.1. Файловая структура модуля

### 4.2. Создание проекта

### 4.3. Работа с модулями приложений



----



### Основные определения и понятия
- *Обьект* - набор полей с данными
- *Сущность* - объект, имеющий идентификатор, с помощью которого система адресуется к содержимому данного объекта.
- *Предикат* - связи между понятиями или экземплярами (таксономические, родственные, 
  производственные), а также свойства сущности (цвет, длина, вкус);
- *Classes* - классы
- *Individuals* – экземпляры класса
- *Data properties* – свойства-литералы
- *Object properties* – свойства-указатели на объекты
- *RDF/RDFS и OWL* – языки представления информации (знаний), которые могут 
  использоваться для описания онтологий как в семантической паутине, так и
  в различных прикладных информационных системах. RDFS является 
  надстройкой над RDF и определяет его базовые конструкции (ресурс, класс,
  подкласс, тип данных, домен и т.п.). Если проводить аналогию с базами 
  данных, то RDFS позволяет задать структуру БД, а RDF наполнить ее 
  содержимым. OWL полностью включает в себя RDF и расширяет его 
  возможности. В прикладных OWL-онтологиях значительная часть описания 
  выполнена с помощью конструкций RDF и RDFS.
- *RDFa* (RDF in attributes) — реализация RDF с помощью записи внутри атрибутов HTML или XHTML разметки








